import asyncio
import zmq
import zmq.asyncio
import json


async def handle_request(identity, message_data):
    """Process individual request asynchronously"""
    try:
        n = json.loads(message_data.decode('utf-8'))

        # Calculate wait time and result as in original example
        wait_time = n % 3 + 1
        result = n + 1

        print(f"Received: {n} from client {identity.hex()}")
        print(f"Waiting {wait_time} seconds...")

        # Simulate async work - this allows other requests to be processed concurrently
        await asyncio.sleep(wait_time)

        print(f"Sending back: {result}")

        return json.dumps(result).encode('utf-8')

    except Exception as e:
        print(f"Error processing request: {e}")
        return json.dumps({'error': str(e)}).encode('utf-8')


async def process_and_reply(socket, identity, empty_frame, message_data):
    """Process request and send reply back to specific client"""
    try:
        # Process the request asynchronously
        response_data = await handle_request(identity, message_data)

        # Send reply back to the specific client using their identity
        await socket.send_multipart([identity, empty_frame, response_data])

    except Exception as e:
        print(f"Error in process_and_reply: {e}")
        error_response = json.dumps({'error': str(e)}).encode('utf-8')
        await socket.send_multipart([identity, empty_frame, error_response])


async def router_server():
    """ROUTER server that can handle multiple clients concurrently"""
    context = zmq.asyncio.Context()
    socket = context.socket(zmq.ROUTER)
    socket.bind("tcp://127.0.0.1:5555")

    print("ROUTER server started on tcp://127.0.0.1:5555")
    print("Waiting for requests...")

    # Keep track of ongoing tasks for proper cleanup
    tasks = set()

    try:
        while True:
            # Receive multipart message: [identity, empty_frame, message]
            # ROUTER automatically prepends identity frame
            parts = await socket.recv_multipart()

            if len(parts) >= 3:
                identity = parts[0]      # Client identity (auto-generated by ROUTER)
                empty_frame = parts[1]   # Empty delimiter frame (from REQ socket)
                message_data = parts[2]  # Actual message payload

                # Create concurrent task to handle this request
                # This allows multiple requests to be processed simultaneously
                task = asyncio.create_task(
                    process_and_reply(socket, identity, empty_frame, message_data)
                )
                tasks.add(task)
                task.add_done_callback(tasks.discard)  # Clean up completed tasks

    except KeyboardInterrupt:
        print("\nShutting down server...")
    finally:
        # Wait for all pending tasks to complete
        if tasks:
            print(f"Waiting for {len(tasks)} pending requests to complete...")
            await asyncio.gather(*tasks, return_exceptions=True)
        socket.close()
        context.term()


if __name__ == "__main__":
    asyncio.run(router_server())
